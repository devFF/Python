# Теоретическая информация о Python
1. Язык программирования Python, его особенности. 
Python - интерпретируемый, высокоуровневый язык с строгой динамической типизацей. 
Интерпретируемость значит, что при каждом запуске код на лету компилируется (преобразуется в байт-код, который удобен для интерпретатора, то есть создается файл .pyc) и лишь затем он выполняется встроенным интерпретатором. 
Динамическая типизация позволяет ранее объявленную переменную одного типа переопредилить как переменную другого типа (a = 5; a = 'five').
Строгая типизация накладывает ограничения на работу с разными типами данных, так, невозможно сложить число и строку ('five' + 5 => error).

1. Модули и пакеты. Модуль в Python - это обычный файл с расширением .py, а пакет - это директория, которая содержит в себе модули.

1. Парадигмы, парадигма ООП. Парадигма - это совокупность правил, которые необходимо соблюлать при написании кода. 
Таким образом, парадигма позволяет стандартизировать написание кода.
ООП - объектно-ориентированное программирование, одна из парадигм, в которой рассматриваются объекты, обладающие своими данными и определенным набором доступных действий.
ООП имеет следующую структуру: 
	- Класс - шаблон для создания объекта; 
	- Объект - экземпляр класса, который обладает методами и атрибутами; 
	- Метод - функция внутри объекта или класса; 
	- Атрибут - характеристика объекта (цена, имя и т.д.).
1. Основные принципы ООП:
	- Инкапсуляция - принцип, согласно которому информация (в том числе методы), которая необходима для работы конкретного объекта хранится 
	только внутри этого объекта. Данный принцип позволяет избежать ошибок при случайных зависимостях, когда меняя один объект мы случайно меняем другой.
	- Наследование. Из названия принципа очевидно, что смысл данного принципа заключается в том, что каждый дочерний элемент может наследовать
	свойства (методы и атрибуты) родительского класса, а также, очевидно, добавлять свои. Профит в том, что не нужно каждый раз заново прописывать 
	методы и атрибуты для новых классов.
	- Полиморфизм - принцип, позволяющий одному и тому же методу работать по-разному в зависимости от места и данных, с которыми он работает. 
	Пример полиморфизма в Python: 5 + 5 = 10 и '5' + '5' = '55'.
	
1. Типы данных: изменяемые и неизменяемые.
	- изменяемые - такой тип данных, которы мы можем, как ни странно, изменять. К изменяемым типам данным относятся: 
	список (list), словарь (dict), множество (set) и байтовые массивы (byte arrays);
	- неизменяемые - такой тип данных, который мы не можем изменить. К неизменяемы относятся все остальные: 
	числа (int, float, complex), булевы значения (bool), строки (str) и кортежи (tuple).
	
1. Асимптотическая сложность алгоритмов и структур данных. По большому счету это время и память, которые понадобятся программа в процессе работы.
При реализации алгоритмов лучше избегать сложности O(N^2) и выше. При больших N справедливо следующее неравенство: 1 < log(n) < n < nlog(n) < n^2 < n!. 
Асимптотика поиска элемента в списке O(N), а в словаре - O(1), так как для ключей словаря используется алгоритм хеширования.
Работа с множеством (set) и кортежем (tuple), а именно вхождение или поиск элемента происходит за  константное время O(1) 
за счёт хэширования каждого элемента структуры по аналогии со словарями.
Примеры сложности некоторых алгоритмов:
	- Поиск элемента обычным перебором - O(N);
	- Поиск элемента бинарным поиском - O(logN);
	- Сортировка списка методом пузырька - O(N^2);
	- Сортировка встроенным методом sorted() - O(NlogN)
	- Вхождение элемента из списка A в список B (A и B - сортированные списки интов) простым перебором - O(N*K) = O(N^2)
	- Вхождение элемента из списка A в список B с использованием двойных указателей - O(N+K) и т.д.
	
1. Контекстный менеджер - представляет собой коснтрукцию вида 'with ... as' и позволяет автоматичеки обрабатывать исключения, и в случае сбоя программы используемый ресурс будет автоматичеки освобожден.
При вызове контекстного менеджера вызывается магический метод \_\_enter__, а при выходе из него вызывается магический метод \_\_exit__.

1. Декоратор - это функция, которая принимает функцию и возвращает функцию. Декораторы используются для расширения функционала функции без изменения ее структуры.
Декоратор может быть вызван выражением decorator = decorator(any_func) или с использованием синтаксического сахара @decorator перед объявлением функции.

1. Итераторы и генераторы. 
	- Генератор - это функция, в которой есть оператор yield. Оператор yield как и оператор return возвращает значение из функции, НО не прерывает ее! Генераторы полезны, когда 
нужно итерироваться по большому количеству значений, но мы не хотим нагружать память, запоминая все эти значения.
	- Итератор - это не есть итерируемый объект (list, str, dict и т.д.), на самом деле это объект, который образуется в результате вызова магического метода \_\_iter__(). 
	Метод \_\_iter__() может быть вызван циклом for. Итерируемые объекты не имеют метода \_\_next__(), а итератор - имеет!

1. Области видимости переменных:
	- Глобальная перменная - такая перменная, которая определена вне функции и доступна, как вне функции, так и в ней и для этого даже не нужно передавать переменную в качестве аргумента функции.
	- Локальная переменная - переменная, которая определяется внутри функции и доступна только в ней.
	- Нелокальная переменная - переменная, перед которой указывается выражение nonlocal. Обычно используется в случае вложенных функций, когда для переменной внутренней функции нужно взять значение
	переменной с тем же названием из внешней функции.
	- Если глобальная и локальная переменная имеют одинаковые наименования, то внутри функции приоритет будет иметь локальное определение.
	
1. Правила именования в Pyhton. 
	- Переменные, методы, модули и пакеты именуются в стиле snake_case (все слова строчными буквами и разделены символом подчеркивания \_);
	- Классы именуются в стиле CamalCase (первая буква каждого слова пишется заглавной);
	- Константы именуются только заглавными буквами в стиле SNAKE_CASE.

1. Виды методов. В Python выделяют статический метод и метод класса.
	- Статический метод (@staticmethod) - метод, который реализует некоторый функционал внутри класса не по отношению к объекту (экземпляру класса), а по всему классу. 
	- Метод класса (@classmethod) - метод, который не привязан к конкретному экземпляру, но в тоже время вовлекает в свою работу сам класс. 
	[Пример](https://github.com/devFF/FindJob/blob/main/General_theory/staticmethod_example.py)
метод принимает на вход первым атрибутом сам класс cls, а затем ввод пользователя. Он возвращает экземпляр класса, таким образом, это альтернативный способ создания класса. 
	[Пример](https://github.com/devFF/FindJob/blob/main/General_theory/classmethod_example.py)
	
1. Property.

1. Магические методы \_\_str__ и \_\_repr__.
	
1. Лямбда-функция. 

1. Сериализация и десериализация. Pickling и Unpickling. Сериализация (pickling - dump) представляет собой процесс преобразования структуры данных в последовательность байтов. 
Для этого в Python может быть использован модуль pickle. Десериализация - обратный процесс сериализации, при котором последовательность байтов превращается в структуру данных (unpickling - load).
Для чего это нужно? Например, можно сохранить состояние обученной нейронной модели. Процесс обучения нейронной сети занимает значительно большее время, чем загрузка ранее обученной модели.
	
	
[Здесь](https://github.com/markdrrr/interview_questions_python_junior) приведен перечень теоретических вопросов для собеседования на должность Junior Python разработчика. 
